[Описание задания](#task)  
[Решение (модульные тесты)](#solution-unit)  
[Решение (интеграционные тесты)](#solution-integration)

# <a name='task'></a>Домашнее задание: автотесты

Вам дано приложение на JavaScript и нужно написать для него автотесты: интеграционные тесты на интерфейс и модульные тесты на серверную часть.

## Предметная область

Приложение отображает в браузере информацию из git репозитория: список коммитов, файловую систему для выбранного коммита, содержимое выбранного файла (поддерживаются только текстовые форматы). Для удобства навигации на каджой странице отображаются "хлебные крошки".

## Как запустить

```sh
git clone git@github.com:dima117/shri-testing-homework.git
cd shri-testing-homework.git
npm i
npm start
```

## Интеграционные тесты

Сценарии для интеграционных тестов

- на всех страницах (история коммитов, просмотр файловой системы, просмотр содержимого файла) правильно отображается их содержимое;
- правильно работают переходы по страницам
  - из списка коммитов на список файлов
  - из списка файлов во вложенную папку
  - из списка файлов на страницу отдельного файла
  - переходы по хлебным крошкам

## Модульные тесты

- нужно добавить в README список логических блоков системы и их сценариев
- для каждого блока нужно написать модульные тесты
- если необходимо, выполните рефакторинг, чтобы реорганизовать логические блоки или добавить точки расширения

# <a name='solution-unit'></a>Решение (модульные тесты)
## Логические блоки
В ходе выполнения были определены следующие логические блоки:
* функции в `./utils/git.js`
  - `executeGit`
  - `gitFileContent`
  - `gitFileTree`
  - `gitHistory`
* функции в `./utils/navigation.js`
  - `buildBreadcrumbs`
  
Для удобства тестирования каждый логический блок был вынесен в отдельный файл.  
`executeGit` был вынесен в `./libs/execute-git.js`, так как он достаточно универсален, остальные оставлены в директории `./utils`, таким образом, файловая структура `./utils` была преобразована в следующую:

`./utils/`
* `git`
  - `git-file-content.js`
  - `git-file-tree.js`
  - `git-history.js`
  - `index.js`
* `navigation`
  - `build-bread-crumbs.js`
  - `build-file-url.js`
  - `build-folder-url.js`
  - `index.js`  

Все вынесеные в отдельные файлы логические блоки были объединены в директории, содержащие index.js, который их экспортирует. Таким образом удалось сохранить первоначальный API для этих модулей. Из navigation будет тестироваться только модуль `build-bread-crumbs.js`, однако, остальные функции так же были вынесены в отдельные файлы с целью сохранения консистентности.

## Тесты
* Рядом с каждым модулем лежит файл его теста с аналогичным названием, но он имеет расширение `.spec.js`. 
* Во всех тестах производится тестирование функций на 1-3 различных аргументах. 
* Во всех тестах на место внешних зависимостей (если они есть) поставлены заглушки.  
* В модуле `./utils/git` производится тестирование логических блоков на то, что:
  - они вызывают функцию `executeGit` с корректными параметрами
  - они возвращают промис, который резолвится в корректный тип данных
  - производится корректный парсинг переданных данных (если таковой присутствует)
* В модуле `./utils/navigation` производится тестирование логического блока `build-bread-crumbs.js` на правильное построение массива хлебных крошек
* В модуле `./libs/execute-git.js` производится тестирование на то, что:
  - производится запуск `child_process.execFile`
  - передаются корректные аргументы в `child_process.execFile` (это как раз важно, потому что они имеют не ту же самую сигнатуру, что аргументы самого `executeGit`)
  - возвращается промис, который резолвится в строку
  
Стоит заметить, что во многих тестах, где тестируется асинхронный код можно заметить следующую конструкцию:
```javascript
return Promise.resolve()
    .then(() => gitFileContent(hash))
    .then(() => 
      expect(executeGit).toBeCalledWith('git', ['show', hash])
    )
```
Она служит для того, чтоб не получать нечитаемых ошибок в тех случаях, когда тест падает из-за того, что по какой-то причине промис не был возвращен. Передача вызова в качестве аргумента в then гарантированно обернет его в промис и прогонит результат через expect, выдав соответствующую тесту ошибку (в данном случае, что функция не была вызвана с нужными аргументами).  
Аналогичная конструкция, которая работает совершенно иначе, но схожа по назначению:
```javascript
const fileContent = gitFileContent('')
expect(fileContent && fileContent.then && fileContent.then(res => typeof res))
  .resolves.toBe('string')
```
Если функция вернет, что-то, что точно не является промисом (так как нет then), например, `undefined`, произойдет краш теста не с непонятной ошибкой "Cannot read property 'then' of undefined" (потому что такое сообщение может так же указывать и на неполадку с тестом), а с сообщением тест-раннера о том, что тест провален из-за того что на выходе был не промис. (в таком случае уже понятно, что проблема не с тестом, а с тестируемым модулем)  

Некоторые тесты, вроде `execute-git.spec.js` могут показаться необязательными, так как там совсем немного кода и всё что проверяемый модуль делает, это промисифицирует `execFile` и вызывает его, однако, в реальной жизни функции могут и разрастаться и если представить, что она разрослась, то она всё ещё должна быть вызывать execFile с аргументами, соответствующими сигнатуре и возвращать промис, резолвящийся в строку. 
## Эволюция моков
Изначально заглушки создавались напрямую. Код был изменен таким образом, что зависимость, на которую требовалась заглушка передавалась в функцию в качестве аргумента со значением по умолчанию и внутри тестов уже передавался дополнительный аргумент с функцией-заглушкой вместо основной. Например:
```javascript
/* БЫЛО: */
// ...
function executeGit(cmd, args) {
  return new Promise((resolve, reject) => {
    execFile(cmd, args, { cwd: REPO }, (err, stdout) => {
// ...
/* СТАЛО: */
// ...
function executeGit(cmd, args, APIFunc = execFile) {
  return new Promise((resolve, reject) => {
     APIFunc(cmd, args, { cwd: REPO }, (err, stdout) => 
// ... 
```
Плюс этого подхода в том, что он сделал тесты простыми для понимания. Однако, минус в том, что это подвергло изменениям API модуля, что, наверное, нежелательно.
Поэтому впоследствие моки создавались для всего файла, а не для отдельной функции, с помощью метода `jest.genMockFromModule`, что позволило вернутся к первоначальному API.

Решение о том, какой из подходов лучше, оставляю на проверяющего, так как сам успел почитать доводы в пользу каждого и интересно было бы узнать мнение кого-то шарящего. 

# <a name='solution-integration'></a>Решение (модульные тесты)
## Запуск
Открыть 3 инстанса терминала с соответствующими командами:
1. `npm start`
1. `npm run selenium`
1. `npm run hermione`
## Файлы Гермионы
Конфиг расположен в `./.hermione.conf.js`  
Файлы тестирования расположены в `./hermione`  
Отчет будет выведен в `./hermione-html-report`
